%% product ROM value
% counter counting from 0 to N-1 when the first valid inputs enters into
% the N-point FFT module. (0 to 31)

% show control signal that sends to the commutator module at each stage to
% control two operation modes(0:switch, 1:bypass operation)

clc
clear

N = 32;

for j =0:floor(N/2)-1 % 16 items
    ROM32(j+1) = cos(2*j*pi/N) - (sin(2*j*pi/N))*1i;
end

for j= 0:floor(N/(2^2))-1 % 8 items
    ROM16(j+1) = cos(2*j*pi/floor(N/2)) - (sin(2*j*pi/floor(N/2)))*1i;
end

for j= 0:floor(N/(2^3))-1 % 4 items 
    ROM8(j+1) = cos(2*j*pi/floor(N/(2^2))) - (sin(2*j*pi/floor(N/(2^2))))*1i;
end

for j= 0:floor(N/(2^4))-1 % 2 items
    ROM4(j+1) = cos(2*j*pi/floor(N/(2^3))) - (sin(2*j*pi/floor(N/(2^3))))*1i;
end

% random array product
clc
%rng('shuffle','simdTwister'); % True-random
rng(429,"twister"); % Pseudo-random
rand_temp = randperm(256)-129;
rand_32 = rand_temp(1,1:32);

rand_32 = mod(rand_32,4)+1;

stem ((1:32),rand_32);

% S and s_ans part

% S = [ 1+i 1-i -1+i -1-i -1-i -1+i 1-i 1+i]; % Y0~Y7

for j = 1:32
    switch(rand_32(j))
        case 1
            S(j) = 1+1i;
        case 2
            S(j) = 1-1i;
        case 3
            S(j) = -1+1i;
        case 4
            S(j) = -1-1i;
        otherwise
            S(j) = 0;
    end

end
s_ans = ifft(S); % ans of y0~y7

%% stage part
% cnt = 0;

% stage1
C1_LI = s_ans;

for cnt= 0:N-1
    [control_stage1(cnt+1),C1_UO(cnt+1), C1_LO(cnt+1)] = commutator1(s_ans(cnt+1), 0 ,cnt);
end

B1_UI = C1_UO(1,1:floor(N/2));
B1_LI = C1_LO(1,floor(N/2)+1:N);

B1_UO = B1_UI + B1_LI;
B1_LO = B1_UI - B1_LI;

% for cnt= floor(N/2):N-1
%     [B1_UO(cnt-(floor(N/2)-1)), B1_LO(cnt-(floor(N/2)-1))] = buttfly1(B1_UI(cnt-(floor(N/2)-1)),B1_LI(cnt-(floor(N/2)-1)),cnt);
% end

M1 = B1_LO(1,1:16).*ROM32(1,1:16);

% stage2

C2_UI = [B1_UO(1,1:16) zeros(1,8)];
C2_LI = [ zeros(1,8) M1 ];

C2_UO = zeros(1,24);
C2_LO = zeros(1,24);

for cnt =16:39
    [ control_stage2(cnt-15),C2_UO(cnt-15), C2_LO(cnt-15)] = commutator2(cnt, C2_UI(cnt-15), C2_LI(cnt-15));
end

C2_UO = circshift(C2_UO,8);

B2_UI = C2_UO(1,9:24);
B2_LI = C2_LO(1,9:24);


% for cnt = 6:9
%     [B2_UO(cnt-5), B2_LO(cnt-5)] = buttfly2(B2_UI(cnt-5),B2_LI(cnt-5),cnt);
% end

B2_UO = B2_UI + B2_LI;
B2_LO = B2_UI - B2_LI;

M2 = B2_LO(1,1:16).*[ROM16(1,1:8) ROM16(1,1:8)];


% stage3

C2_UI = [B1_UO(1,1:16) zeros(1,8)];
C2_LI = [ zeros(1,8) M1 ];


C3_UI = [B2_UO  zeros(1,4)];
C3_LI = [ zeros(1,4) M2 ];

C3_UO = zeros(1,20);
C3_LO = zeros(1,20);

for cnt = 24:43
    [ control_stage3(cnt-23),C3_UO(cnt-23), C3_LO(cnt-23)] = commutator3(cnt, C3_UI(cnt-23), C3_LI(cnt-23));
end
C3_LO = circshift(C3_LO,-4);


B3_UI = C3_UO(1,1:16);
B3_LI = C3_LO(1,1:16);


B3_UO = B3_UI + B3_LI;
B3_LO = B3_UI - B3_LI;

M3 = B3_LO(1,1:16).*[ROM8(1,1:4) ROM8(1,1:4) ROM8(1,1:4) ROM8(1,1:4)];



%%
final = [B3_UO(1) B3_UO(3) B3_UO(2) B3_UO(4) B3_LO(1) B3_LO(3) B3_LO(2) B3_LO(4)];

plot(abs(final-S))
% set(gca, 'YScale', 'log')
